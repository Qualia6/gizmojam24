[preset.0]

name="Web"
platform="Web"
runnable=true
dedicated_server=false
custom_features=""
export_filter="all_resources"
include_filter=""
exclude_filter=""
export_path=""
encryption_include_filters=""
encryption_exclude_filters=""
encrypt_pck=false
encrypt_directory=false

[preset.0.options]

custom_template/debug=""
custom_template/release=""
variant/extensions_support=false
vram_texture_compression/for_desktop=true
vram_texture_compression/for_mobile=false
html/export_icon=true
html/custom_html_shell=""
html/head_include="<script>
const rows_power = 5
const cols_power = 5
const rows = 1<<(rows_power)
const cols = 1<<(cols_power)
const size = 1<<(rows_power+cols_power)
const colBitMask = size-rows
const rowBitMask = rows-1

const CONSTRUCTOR_FLAG = 0b1
const UPDATE_FLAG = 0b10
const TICK_FLAG = 0b100

const temperatures = new Int32Array(size) // only store values between -8000 and 8000 otherwise it will over flow when spreading
const types = new Uint8Array(size) // odd types are ticking, even types don't tick
const data0 = new Int16Array(size) // more data arrays can be added and will work exactly as you exact as long as they are size size

// this manages the queue
// dontQueue is just bit for every cell in the world - if its high then its already queued (ensures that something can only be queued once)
// updateQueued is an array of all the cells that need updates. The most significant 2 bits represent the direction that the update came from (0-up, 1-right, 2-down, 3-left)
// queue position is the index in the queue where the next thing should be added at.
//every tick, the queue is processed - but if new things are added to it during that time they will not be (and will be moved to the front queue for the next tick)
let updateQueued = new Uint32Array(16) // 16 is random choice - will be dynamically made larger when needed
const dontQueue = new DataView(new ArrayBuffer(size>>3)) // because 8 bits a byte, 2^3=8 so size>>3 bytes has size bits
let queuePosition = 0

function getQueuedByte(i) {
	const byteOffset = i>>3// /8
	return dontQueue.getUint8(byteOffset)
}

function isQueued(i,queuedByte) {
	const bitPosition = i&7// %8
	const maskBit = 1<<bitPosition
	return (queuedByte & maskBit) !== 0
}

function writeFalseQueued(i, queuedByte) {
	const byteOffset = i>>3// /8
	const bitPosition = i&7// %8
	const maskNotBit = ~(1<<bitPosition)
	dontQueue.setUint8(byteOffset, queuedByte & maskNotBit)
}

function writeTrueQueued(i, queuedByte) {
	const byteOffset = i>>3// /8
	const bitPosition = i&7// %8
	const maskBit = 1<<bitPosition
	dontQueue.setUint8(byteOffset, queuedByte | maskBit)
}

function hasFlag(i, flag) {
	return (flags[types[i]] & flag) !== 0
}

const temp = new Int32Array(size)

function changeBlock(i, whatNewType, updateEvenIfSameType, evenIfInvalid, dontSendUpdates) {
	if (types[i] != i || updateEvenIfSameType) {
		let previousType = types[i]
		types[i] = whatNewType
		let valid = true
		if (hasFlag(i, CONSTRUCTOR_FLAG)) {
			valid = constructorCallbacks[whatNewType](i)
		}
		if (valid || evenIfInvalid) {
			if (!dontSendUpdates) sendAdjacentUpdates(i)
		} else {
			types[i] = previousType //if invalid - dont change the type
		}
	}
}

function addUpdateToQueue(i, direction) {
	if (!hasFlag(i,UPDATE_FLAG)) return

	const byte = getQueuedByte(i)
	const dontQueue = isQueued(i,byte)
	if (dontQueue) return
	writeTrueQueued(i,byte)

	const valueToQueue = i|(direction<<30) // the 2 most significant bits are the direction the update came from

	try {
		updateQueued[queuePosition] = valueToQueue;
	} catch (e) { // if updateQueued is toooo smalll - make it bigger
		let newUpdateQueued = new Int32Array(updateQueued.length*2);
		newUpdateQueued.set(updateQueued);
		updateQueued = newUpdateQueued
		updateQueued[queuePosition] = valueToQueue
	}

	queuePosition++;
}

// tested
function isNotTop(i) {
	return (~i)&colBitMask
}

// tested
function isNotBottom(i) {
	return i&colBitMask
}

// tested
function isNotLeft(i) {
	return (~i)&rowBitMask
}

// tested
function isNotRight(i) {
	return (~i)&rowBitMask
}

function sendAdjacentUpdates(i) {
	if (isNotTop(i)) addUpdateToQueue(i+rows,0)
	if (isNotLeft(i)) addUpdateToQueue(i+1,1)
	if (isNotBottom(i)) addUpdateToQueue(i-rows,2)
	if (isNotRight(i)) addUpdateToQueue(i-1,3)
}

// should return true if a block is placed
// false if it is not valid to place there
const constructorCallbacks = []
const updateCallbacks = []
const tickCallbacks = []
const flags = []

function createType(id, constructor, update, tick) {
	if (flags[id] !== undefined) {
		throw \"Tried to make two types with same id \" + id
	}
	let flag = 0
	if (constructor) {
		flag |= CONSTRUCTOR_FLAG
		constructorCallbacks[id] = constructor
	}
	if (update) {
		flag |= UPDATE_FLAG
		updateCallbacks[id] = update
	}
	if (tick) {
		flag |= TICK_FLAG
		tickCallbacks[id] = tick
	}

	flags[id] = flag
}

function roundingDivideBySixteen(value) {
	return (value>>4)+((value>>3)&1)
}

function spread(array) { // convolves over the entire thing with a kernel of 121 242 121
	let i = 0
	let A = 0
	let B = 0
	let C = 0
	while (i < size) {
		A = array[i + 1]
		B = array[i]
		temp[i] = A + (B<<1) + B
		const stopLoop = i + cols - 2
		while (i < stopLoop) {
			++i
			C = B
			B = A
			A = array[i + 1]
			temp[i] = A + (B<<1) + C
		}
		++i
		C = B
		B = A
		temp[i] = B + (B<<1) + C
		++i
	}
	const lastRow = size - cols
	i = 0
	while (i < cols) {
		A = temp[i + cols]
		B = temp[i]
		array[i] = roundingDivideBySixteen(A + (B<<1) + B)
		const stopLoop = lastRow - cols
		while (i < stopLoop) {
			i += cols
			C = B
			B = A
			A = temp[i + cols]
			array[i] = roundingDivideBySixteen(A + (B<<1) + C)
		}
		i += cols
		C = B
		B = A
		array[i] = roundingDivideBySixteen(B + (B<<1) + C)
		i -= lastRow - 1
	}
}

function preformUpdate(queueIndex) {
	const value = updateQueued[queueIndex]
	const twoMostSignificantBitsMask = ~(0b11<<30)
	const i = value & twoMostSignificantBitsMask
	const direction = value >> 30
	const byte = getQueuedByte(i)
	writeFalseQueued(i, byte) // remove queue mark (important top do this first so that anything else that triggers this to be updated again puts it in the queue to be updated again - next tick)

	if (hasFlag(i,UPDATE_FLAG)) { // incase the block changed since it got queued
		console.log(i,types[i])
		updateCallbacks[types[i]](i,direction)
	}
}

function fulfillUpdateQueue() {
	let stopDoingUpdates = queuePosition // if new updates are added after this point they will be pushed to next tick
	for (let queueIndex=0; queueIndex<stopDoingUpdates; queueIndex++) {
		preformUpdate(queueIndex)
	}
	// move new updates down so that they are starting at the begining for next tick
	for (let queueIndex=stopDoingUpdates; queueIndex<queuePosition; queueIndex++) {
		updateQueued[queueIndex-stopDoingUpdates] = updateQueued[queueIndex]
	}
	queuePosition -= stopDoingUpdates
}

function tickCells() {
	for (let i = 0; i < size; i++) {
		let type = types[i]
		if (hasFlag(i,TICK_FLAG)) {
			tickCallbacks[type](i)
		}
	}
}

function tick() {
	spread(temperatures)
	tickCells()
	fulfillUpdateQueue()
}


createType(0) // does nothing
createType(1, // heats up
	false, 
	false,
	i=>{ 
		temperatures[i] += 100
	}
)
createType(2, // cant be place next to left or right edge & swaps heat on the left and right
	i=>{
		if (!isNotLeft(i) || !isNotRight(i)) {
			return false
		} 
		return true
	}, 
	false,
	i=>{ 
		trans = temperatures[i + 1]
		temperatures[i + 1] = temperatures[i - 1]
		temperatures[i - 1] = trans
	}
)
createType(3, // combusts at temperature >200
	i=>{
		data0[i] = 10
		return true
	},
	false,
	i=>{
		if (temperatures[i] > 500) {
			temperatures[i] += 2000
			data0[i]--
			if (data0[i]==0) {
				changeBlock(i,0)
			}
		}
	}
)
createType(4, // after 50 tick converts to type 1
	i=>{
		data0[i] = 0
		return true
	},
	false,
	i=>{
		data0[i]++
		if (data0[i] == 50) {
			changeBlock(i,0)
		}
	}
)
createType(5, // falling sand - switches to 6 when it lands
	false,
	false,
	i=>{
		if (isNotBottom(i) && types[i-rows] == 0) {
			changeBlock(i-rows,5)
			changeBlock(i,0)
		} else {
			changeBlock(i,6)
		}
	}
)
createType(6, //sand waiting to fall (no longer ticking) (is receiving updates and if it triggers to fall again will switch to type 5 again)
	i => {
		if (isNotBottom(i) && types[i-rows] == 0) {
			types[i] = 5 // normally use changeBlock, but in the constructor this is the only kinda ok place to do this
		}
		return true
	},
	(i, direction) => { //direction 2 is down
		if (/* direction == 2 &&  */isNotBottom(i) && types[i-rows] == 0) {
			changeBlock(i,5)
		}
	},
	false
)


function debug_display(array) {
	if (typeof(array) == Function) {
		let result = \"\"
		let i = 0
		while (i < size) {
			const stopLoop = i + cols
			while (i < stopLoop) {
				result += array(i) + \" \"
				++i
			}
			result += \"\\n\"
		}
		console.log(result)
	} else {
		let result = \"\"
		let i = 0
		while (i < size) {
			const stopLoop = i + cols
			while (i < stopLoop) {
				result += array[i] + \" \"
				++i
			}
			result += \"\\n\"
		}
		console.log(result)
	}

}

changeBlock(5*rows+3,1)
changeBlock(3*rows+5,1)
changeBlock(5*rows+5,1)
changeBlock(3*rows+3,1)
changeBlock(4*rows+3,1)
changeBlock(3*rows+4,1)
changeBlock(4*rows+4,1)
changeBlock(4*rows+5,1)
changeBlock(5*rows+4,1)
changeBlock(7*rows+5,3)
changeBlock(10*rows+5,3)
changeBlock(13*rows+5,3)
changeBlock(16*rows+5,3)
changeBlock(19*rows+5,3)
changeBlock(22*rows+5,3)
changeBlock(25*rows+5,3)
changeBlock(25*rows+8,3)
changeBlock(25*rows+11,3)
changeBlock(25*rows+14,3)
changeBlock(25*rows+17,3)
changeBlock(25*rows+20,3)
changeBlock(23*rows+23,3)
changeBlock(23*rows+24,3)
changeBlock(23*rows+25,3)
changeBlock(23*rows+26,3)
changeBlock(23*rows+27,3)
changeBlock(24*rows+23,3)
changeBlock(24*rows+24,3)
changeBlock(24*rows+25,3)
changeBlock(24*rows+26,3)
changeBlock(24*rows+27,3)
changeBlock(25*rows+23,3)
changeBlock(25*rows+24,3)
changeBlock(25*rows+25,3)
changeBlock(25*rows+26,3)
changeBlock(25*rows+27,3)
changeBlock(26*rows+23,3)
changeBlock(26*rows+24,3)
changeBlock(26*rows+25,3)
changeBlock(26*rows+26,3)
changeBlock(26*rows+27,3)
changeBlock(27*rows+23,3)
changeBlock(27*rows+24,3)
changeBlock(27*rows+25,3)
changeBlock(27*rows+26,3)
changeBlock(27*rows+27,3)


changeBlock(10*rows+11,4)
changeBlock(10*rows+12,4)
changeBlock(10*rows+13,5)
changeBlock(11*rows+11,5)
changeBlock(11*rows+12,5)
changeBlock(12*rows+11,5)
changeBlock(12*rows+12,5)
</script>"
html/canvas_resize_policy=2
html/focus_canvas_on_start=true
html/experimental_virtual_keyboard=false
progressive_web_app/enabled=false
progressive_web_app/offline_page=""
progressive_web_app/display=1
progressive_web_app/orientation=0
progressive_web_app/icon_144x144=""
progressive_web_app/icon_180x180=""
progressive_web_app/icon_512x512=""
progressive_web_app/background_color=Color(0, 0, 0, 1)
